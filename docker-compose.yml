services:
  

  setup-permissions-fix:
    image: busybox
    container_name: elastic-setup-certs-permissions
    user: "0" 
    command: sh -c 'mkdir -p /usr/share/elasticsearch/config/certs && chown -R 1000:1000 /usr/share/elasticsearch/config/certs'
    volumes:
      - certs:/usr/share/elasticsearch/config/certs
  setup:
    image: docker.elastic.co/elasticsearch/elasticsearch:${ELASTIC_VERSION}
    container_name: elastic-setup-certs
    volumes:
      - certs:/usr/share/elasticsearch/config/certs
    user: "1000"
    command: >
      bash -c '
        if [ ! -f config/certs/ca.zip ]; then
          # Removed --pass="" to create a passwordless CA key, avoiding the interactive prompt bug
          elasticsearch-certutil ca --silent --pem -out config/certs/ca.zip;
          unzip config/certs/ca.zip -d config/certs;
        fi;
        if [ ! -f config/certs/certs.zip ]; then
          echo -ne "instances:\n  - name: elasticsearch\n    dns:\n      - elasticsearch\n      - localhost\n    ip:\n      - 127.0.0.1\n" > config/certs/instances.yml;
          # Removed --ca-pass="" because the CA key is now passwordless
          elasticsearch-certutil cert --silent --pem -out config/certs/certs.zip --in config/certs/instances.yml --ca-cert config/certs/ca/ca.crt --ca-key config/certs/ca/ca.key;
          unzip config/certs/certs.zip -d config/certs;
        fi;
      '
    environment:
      - ES_JAVA_OPTS=-Djava.security.egd=file:/dev/urandom
    tty: true
    mem_limit: 2g
    depends_on:
      setup-permissions-fix:
        condition: service_completed_successfully
  
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:${ELASTIC_VERSION}
    container_name: elasticsearch
    secrets:
      - elastic_password
      - healthcheck_password
    volumes:
      - certs:/usr/share/elasticsearch/config/certs
      - es_data:/usr/share/elasticsearch/data
    environment:
      - ELASTIC_PASSWORD_FILE=/run/secrets/elastic_password
      - discovery.type=single-node
      - xpack.security.enabled=true
      - xpack.security.http.ssl.enabled=true
      - xpack.security.http.ssl.key=/usr/share/elasticsearch/config/certs/elasticsearch/elasticsearch.key
      - xpack.security.http.ssl.certificate=/usr/share/elasticsearch/config/certs/elasticsearch/elasticsearch.crt
      - xpack.security.http.ssl.certificate_authorities=/usr/share/elasticsearch/config/certs/ca/ca.crt
      - xpack.security.transport.ssl.enabled=true
      - xpack.security.transport.ssl.key=/usr/share/elasticsearch/config/certs/elasticsearch/elasticsearch.key
      - xpack.security.transport.ssl.certificate=/usr/share/elasticsearch/config/certs/elasticsearch/elasticsearch.crt
      - xpack.security.transport.ssl.certificate_authorities=/usr/share/elasticsearch/config/certs/ca/ca.crt
    mem_limit: 2g
    ulimits:
      memlock:
        soft: -1
        hard: -1
    healthcheck:
      test: ["CMD-SHELL", "sh -c 'curl -s --fail --cacert config/certs/ca/ca.crt -u elastic:$(cat /run/secrets/elastic_password) https://localhost:9200/_cluster/health' | grep -vq '\"status\":\"red\"'"]
      interval: 20s      
      timeout: 10s
      retries: 10    
      start_period: 180s
    networks: ["netguard-net"]
    depends_on:
      setup:
        condition: service_completed_successfully

  setup-passwords:
    image: curlimages/curl:latest
    container_name: elastic-setup-passwords
    secrets:
      - elastic_password
    user: "1000"
    read_only: true
    cap_drop: [ALL]
    depends_on:
      elasticsearch:
        condition: service_healthy
    command: >
      sh -c '
        ELASTIC_PASSWORD=$(cat /run/secrets/elastic_password) &&
        until curl -s --cacert /certs/ca/ca.crt -u elastic:"$$ELASTIC_PASSWORD" https://elasticsearch:9200/_cluster/health?wait_for_status=yellow&timeout=10s; do
          echo "Waiting for Elasticsearch..."; sleep 5;
        done;
        echo "Setting password for kibana_system user via API...";
        curl -s -X PUT "https://elasticsearch:9200/_security/user/kibana_system/_password" \
             --cacert /certs/ca/ca.crt -u elastic:"$$ELASTIC_PASSWORD" \
             -H "Content-Type: application/json" \
             -d "{\"password\": \"$$ELASTIC_PASSWORD\"}";
        echo "Password for kibana_system user has been set.";
      '
    volumes:
      - certs:/certs:ro
    networks:
      - netguard-net

  kibana:
    image: docker.elastic.co/kibana/kibana:${ELASTIC_VERSION}
    container_name: kibana
    secrets:
      - elastic_password
      - kibana_security_key
      - kibana_savedobjects_key
      - kibana_reporting_key
    volumes:
      - certs:/usr/share/kibana/config/certs:ro
    environment:
      - ELASTICSEARCH_HOSTS=https://elasticsearch:9200
      - ELASTICSEARCH_USERNAME=kibana_system
      - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES=/usr/share/kibana/config/certs/ca/ca.crt
      - SERVER_PUBLICBASEURL="https://${SERVER_HOSTNAME}/kibana"
      - SERVER_BASEPATH="/kibana"
      - SERVER_SSL_ENABLED=true
      - SERVER_SSL_CERTIFICATE=/usr/share/kibana/config/certs/elasticsearch/elasticsearch.crt
      - SERVER_SSL_KEY=/usr/share/kibana/config/certs/elasticsearch/elasticsearch.key
      - XPACK_SECURITY_ENCRYPTIONKEY_FILE=/run/secrets/kibana_security_key
      - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY_FILE=/run/secrets/kibana_savedobjects_key
      - XPACK_REPORTING_ENCRYPTIONKEY_FILE=/run/secrets/kibana_reporting_key
    ports: ["5601:5601"]
    command: >
      sh -c '
        export ELASTICSEARCH_PASSWORD=$$(cat /run/secrets/elastic_password) &&
        /usr/local/bin/kibana-docker
      '
    depends_on:
      elasticsearch:
        condition: service_healthy
      setup-passwords:
        condition: service_completed_successfully
    networks: ["netguard-net"]
    healthcheck:
      test: ["CMD-SHELL", "curl -s --cacert /usr/share/kibana/config/certs/ca/ca.crt https://localhost:5601/api/status | grep -q '\"level\":\"available\"'"]
      interval: 10s
      timeout: 10s
      retries: 5


  elastic-setup:
    build:
      context: .
      dockerfile: Dockerfile.elastic-setup
    container_name: elastic-setup-runner
    user: "0"
    volumes:
      - certs:/certs:ro
    networks:
      - netguard-net
    secrets:
      - elastic_password
      - healthcheck_password
    environment:
      - ELASTIC_PASSWORD_FILE=/run/secrets/elastic_password
      - HEALTHCHECK_PASSWORD_FILE=/run/secrets/healthcheck_password
    depends_on:
      elasticsearch:
        condition: service_healthy


  db:
    image: postgres:15-alpine
    container_name: postgres_db
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
      POSTGRES_DB: ${POSTGRES_DB}
    secrets:
      - postgres_password
    volumes: ["postgres_data:/var/lib/postgresql/data"]
    networks: ["netguard-net"]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 10

  netguard_app:
    build: { context: ., dockerfile: Dockerfile.netguard }
    container_name: netguard_app
    networks: ["netguard-net"]
    secrets:
      - postgres_password
      - elastic_password
    volumes:
      - suricata_logs:/var/log/suricata:ro
      - packet_stream:/stream
      - certs:/usr/share/certs/:ro
    depends_on:
      elasticsearch:
        condition: service_healthy
      db:
        condition: service_healthy
      nmap-scanner:
        condition: service_started
    environment:
      - IFACE=${IFACE}
      - SCAN_TARGET_CIDR=${SCAN_TARGET_CIDR}
      - ELASTICSEARCH_URI=https://elasticsearch:9200
      - ELASTICSEARCH_SSL_CA_CERTS=/usr/share/certs/ca/ca.crt
      - ELASTIC_USER=elastic
      - PYTHONUNBUFFERED=1
      - DB_HOST=db
      - DB_PORT=5432
      - DB_USER=${POSTGRES_USER}
      - DB_NAME=${POSTGRES_DB}

  nginx:
    image: nginx:1.25-alpine
    container_name: nginx_proxy
    ports: ["80:80", "443:443"]
    environment:
      SERVER_HOSTNAME: ${SERVER_HOSTNAME}
    volumes:
      - ./nginx/nginx.conf.template:/etc/nginx/nginx.conf.template:ro
      - ./nginx/conf.d/default.conf.template:/etc/nginx/conf.d/default.conf.template:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    networks: ["netguard-net"]
    depends_on:
      netguard_app:
        condition: service_started
      kibana:
        condition: service_healthy
    extra_hosts: ["host.docker.internal:host-gateway"]
    restart: unless-stopped
    command: >
      sh -c "envsubst '\$${SERVER_HOSTNAME}' < /etc/nginx/nginx.conf.template > /etc/nginx/nginx.conf && envsubst '\$${SERVER_HOSTNAME}' < /etc/nginx/conf.d/default.conf.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"

  packet-streamer:
    build: { context: ., dockerfile: Dockerfile.tshark }
    container_name: packet-streamer
    restart: unless-stopped
    network_mode: "host"
    cap_drop:
    - ALL
    cap_add: [ "NET_RAW", "NET_ADMIN" ]
    read_only: true
    tmpfs: /tmp
    volumes: ["packet_stream:/stream"]
    command: >
      sh -c "
        if [ ! -p /stream/scapy.pcap ]; then mkfifo /stream/scapy.pcap; fi &&
        tshark -i ${IFACE} -l -T ek > /stream/scapy.pcap
      "

  zeek:
    build: { context: ., dockerfile: Dockerfile.zeek }
    container_name: zeek
    restart: on-failure
    depends_on:
      pcap-permissions-fix:
        condition: service_completed_successfully
      zeek-permissions-fix:
        condition: service_completed_successfully
    volumes:
      - zeek_logs:/opt/zeek/logs
      - pcap_spool:/pcaps
      - ./local.zeek:/opt/zeek/share/zeek/site/local.zeek
      - ./process_pcaps.sh:/usr/local/bin/process_pcaps.sh:ro
    user: "1002:998"
    mem_limit: 2g
    cpus: '1.0'
    command: /usr/local/bin/process_pcaps.sh

  suricata:
    image: jasonish/suricata:latest
    container_name: suricata
    restart: unless-stopped
    network_mode: "host"
    depends_on:
      pcap-permissions-fix:
        condition: service_completed_successfully
      suricata-permissions-fix:
        condition: service_completed_successfully
    cap_add:
      - NET_ADMIN
      - NET_RAW
      - SYS_NICE
    volumes:
      - ./suricata.yaml:/etc/suricata/suricata.yaml
      - ./suricata-rules:/etc/suricata/rules
      - suricata_logs:/var/log/suricata
      - pcap_spool:/pcaps
    mem_limit: 2g
    cpus: '1.0'
    command: ["-i", "${IFACE}", "-c", "/etc/suricata/suricata.yaml", "-l", "/pcaps", "--user=suricata", "--group=suricata"] 

  filebeat:
    image: docker.elastic.co/beats/filebeat:${ELASTIC_VERSION}
    container_name: filebeat
    secrets:
      - elastic_password
    depends_on:
      elastic-setup:
        condition: service_completed_successfully
      elasticsearch:
        condition: service_healthy
      zeek:
        condition: service_started
      suricata:
        condition: service_started
      setup-passwords:
        condition: service_completed_successfully
    user: "1000"
    group_add:
      - "998"
    restart: on-failure
    volumes:
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml:ro
      - zeek_logs:/opt/zeek/logs:ro
      - pcap_spool:/pcaps:ro
      - suricata_logs:/var/log/suricata:ro
      - certs:/usr/share/filebeat/config/certs:ro
    networks: ["netguard-net"]
    command: > 
      sh -c '
        export ELASTIC_PASSWORD=$(cat /run/secrets/elastic_password) &&
        filebeat -e -d "*" --strict.perms=false
      '


  nmap-scanner:
    build:
      context: .
      dockerfile: Dockerfile.nmap-scanner
    container_name: nmap-scanner
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    cap_add:
      - NET_ADMIN
      - NET_RAW
    networks: ["netguard-net"]
    secrets:
      - postgres_password
    environment:
      - SCAN_TARGET_CIDR=${SCAN_TARGET_CIDR}
      - PYTHONUNBUFFERED=1
      - DB_HOST=db
      - DB_PORT=5432
      - DB_USER=${POSTGRES_USER}
      - DB_NAME=${POSTGRES_DB}

  pcap-permissions-fix:
    image: busybox
    container_name: pcap-permissions-fix
    command: sh -c "chown 998:998 /pcaps && chmod 775 /pcaps"
    volumes: ["pcap_spool:/pcaps"]


  suricata-permissions-fix:
    image: busybox
    container_name: suricata-permissions-fix
    command: sh -c "chown 998:998 /var/log/suricata"
    volumes: ["suricata_logs:/var/log/suricata"]


  zeek-permissions-fix:
    image: busybox
    container_name: zeek-permissions-fix
    command: sh -c "chown 1002:998 /opt/zeek/logs"
    volumes: ["zeek_logs:/opt/zeek/logs"]



volumes:
  certs: {}
  es_data: {}
  postgres_data: {}
  zeek_logs: {}
  suricata_logs: {}
  pcap_spool: {}
  packet_stream: {}

networks:
  netguard-net: {}

secrets:
  postgres_password:
    file: ./.secrets/postgres_password.secret
  elastic_password:
    file: ./.secrets/elastic_password.secret
  kibana_security_key:
    file: ./.secrets/kibana_security_key.secret
  kibana_savedobjects_key:
    file: ./.secrets/kibana_savedobjects_key.secret
  kibana_reporting_key:
    file: ./.secrets/kibana_reporting_key.secret
  healthcheck_password:
    file: ./.secrets/healthcheck_password.secret
